# .NET Apps

- C# Programming Language
- Hight-Level Language aka defacto Programming model for .NET Apps
- 100% OOPs
- Support for, Desktop, Web, Mobile, Cloud, ML, Gaming, and IoT Apps
- Programming Concepts
	- namespace
		- collection of similar behavior classes, based on Proncipal of Single-Responsibility
		- a namespace can have other namespaces
		- The 'System' is the highest level namespce for Application Dev.
			- Database, Collection, Files, etc	 
		- The .NET Application Dev. Runtime has 'Microsoft' as top level namespace
			- Microsoft.NetCore.App
				- All .NET Apps 
			- Microsoft.AspNetCore.App
				- Only for ASP.NET Core Eco-System (Pages, MVC, API, Blazor)
	- Application Runtime
		- dotnet.exe, Cross-Platform
			- A Host for .NET Apps, this loads following components while running the application
				- Standard .NET Libs, also know as Framework Classs Library (FCL)
				- Runtime Services
					- Memory Mangement
					- Code-Optimizer based on the version 
				- Runtime Dependencies
					- All Standard and externally referred Packages (aka libraries) 
				- The Application intermidiate code (Intermidiate Language OR IL)
	- LOng Term Support (LTS)
		- Production Ready support across Apps across all suported OS including Docker
	- Standard Term Support
		- Available for Current Version for Production, but aftre Next release this may be revoked or removed 
# C# Application
- Main() as enrtypoint
	- .NET 6, the Main() is implicit in Program.cs
	- The Main() methid is a part of 'Program' class and all methods in the Program class are 'static'
- .NET Types
	- Vale and Ref types	
	- The 'char', with size is 2 bytes
	- The 'string' size is (Length*2 + 2) bytes
- The 'System.Type' is the Type class that is used to read the 'typeof()' each declaratrion in .NET using the 'GetType()' method
	
- Object Oriented Programming (OOPs)
	- Abstratcion and Encapsulation
		- Data Encapsulation, with Data Members
		- Behavior Abstratcion with Methods and Properties
	- Inheritance
		- we cannot have multiple interitance 
	- Polymorphism
- Class
	- Members with Access Specifiers
		- public, private, protected, internal, protected internal
			- public: Visiable to entire application
			- private: Only within the class, default for each member of the class
			- protected: Within declaring and derived class in same namespace
			- internal: Visiable across all classes with the namespace, this is default for all classes and interface 
			- protected internal: Same as 'internal' but also accessible across derived classed in different assembly
		- Members Types as follows
			- Data Members
				- Private, Public, Protected declarations those holds values for the class
			- Properties
				- Intelligent Fields because they have 'setter' and 'getter' blocks for defininmg logic for the private data member
			- Methods
			- Events 
	- Modifiers
		- Static, same as 'shared' thread-safe
		- abstract, class must be inherited
			- abstract class and abstract methods
				- abstract methgod must be overriden 
		- sealed, class cannot be inherited
		- virtual, for methods, these have implementation that can be either overriden or may be used as it is by the derived class
- The 'new' nmoniker, the keyword (aka operator) that is used to instantiate the object
	- The memory is allocated for the declaration	
- Code-Debugging
	- F9 key for Applying Breakpoints
	- F10, Step Over
	- F11, Strp into
	- F5 Run the Application
		

# Applied OOPs
- Using the OOPs concepts for Application Development
- Neatly implement 
	- Data Encapsulation, aka Properties
	- Behavior Abstratcion, aka Methods
		- A Generlize Behavior class that contains definition for generalized Read/Write Requirements  
		- Using 'abstract' class
			- It can have following modifiers for methods
				- The 'virtual' methods
					- They have implementation
				- The 'abstract' methods
					- The do not have any implementation (same as PURE Vurtual Function in C++) 
			- The abstrct class MUST be derived by the derived class(es)
				- The drived class MUST 'override' 'abstract' methods of the abstract class else the derive class MUST be modified as 'abstract' class
				- The derived class may or may not override the virtual methods of the abstract base class instaed derived class can directly access implementation of virtual methods
	- Inheritence
		- Code (aka Logic) reusability
			- Implementation of Open for extension Close for modification  Principal (OCP) 
	- Polymorphism
		- Runtime behavior that will be executed for the class method, based on the Invoking object as well as the input parameter(s)  for the method at runtime  
- Interfaces
	- Abstract classes are fastest in Cohesive System where all derivations are present within the system itself (Namespace or Assembly)
	- But if our need is to stablish communication accross systems (Homogeneous or Hetrogeneous) with decoupling then its always receommended to use 'Interface'
	- The 'interface' is a keyword
	- Its internal by default
	- All methods declared in interface uses same access specifier of the interface
	- Methods does not have any implementation (Note C# 9.0+ the interface method can have a default implementation)
	- IMP*****
		- a class can implement one-or-more interfaces
		- all methods of interface MUST be implemented by class
		- Interface can be implmented by class using one of the following way
			- Implicit: Methods are present in class and access by interface reference as well as class instance
			- Explict: Methods are present in class but they can be accessed only using the interface reference
				- This is recommended if the class implement multiple interfaces and these interfaces have same methods with same signeture 	



